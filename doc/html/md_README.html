<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Merlin: Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Merlin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_README.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="classMerlin.html">Merlin</a> is a general purpose <code>C++</code> library that implements state-of-the-art exact and approximate algorithms for probabilistic inference over graphical models including both directed and undirected models (e.g., Bayesian networks, Markov Random Fields). It can be used for many applications and research in bioinformatics, computer vision, or speech and language processing to name a few. <a class="el" href="classMerlin.html">Merlin</a> supports the most common probabilistic inference tasks such as computing the partition function or probability of evidence (PR), posterior marginals (MAP), as well as MAP (also known as maximum aposteriori or most probable explanation) and marginal MAP configurations.</p>
<p><a class="el" href="classMerlin.html">Merlin</a> implements the classic Loopy Belief Propagation (LBP) algorithm as well as more advanced generalized belief propagation algorithms such as Iterative Join-Graph Propagation (IJGP) and Weighted Mini-Bucket Elimination (WMB). The default algorithm for computing all four probabilistic inference tasks (PR, MAR, MAP, MMAP) is WMB(i). The algorithm is parameterized by an i-bound that allows for a controllable tradeoff between accuracy of the results and the computational cost. Larger values of the i-bound typically yield more accurate results but it takes more time and memory to compute them. Selecting a large enough i-bound allows for exact inference (i.e., i-bound equal to the treewidth of the model). For relatively small i-bounds <a class="el" href="classMerlin.html">Merlin</a> performs approximate inference.</p>
<h1>API</h1>
<h2>Basic (Black-Box) API</h2>
<p><a class="el" href="classMerlin.html">Merlin</a> exposes (see <code><a class="el" href="merlin_8h_source.html">merlin.h</a></code> header) a single C-like function called <code>run()</code>: </p><pre class="fragment">    int run(const char* inputFile, 
        const char* evidenceFile, 
        const char* queryFile, 
        const char* outputFile, 
        const char* task, 
        const unsigned int ibound, 
        const unsigned int iterations);
</pre><p>where:</p><ul>
<li><code>inputFile</code> - name of the file containing the input graphical model specified in the UAI format (see main documentation for details on the format).</li>
<li><code>evidenceFile</code> - name of the file containing the evidence or observations as variable and value pairs (variable indeces are the same as in the <code>inputFile</code>).</li>
<li><code>queryFile</code> - name of the file containing the query variable for the marginal MAP inference task (variable indeces are the same as in the <code>inputFile</code>).</li>
<li><code>outputFile</code> - name of the file containing the result of the inference task (see main documentation for details on the format).</li>
<li><code>task</code> - name of the probabilistic inference task. The following names can be used: PR, MAR, MAP, MMAP.</li>
<li><code>ibound</code> - parameter i-bound of the inference algorithm <code>WMB(i)</code> controling the accuracy of the results. The value should be greater or equal to 2 (default is 2).</li>
<li><code>iterations</code> - parameter iterations of the inference algorithm <code>WMB(i)</code> specifing the number of iterations to be executed (default is 100).</li>
</ul>
<p>The function returns 0 if successful, in which case the output file contains the solution to the probabilistic inference task. Otherwise, the return value is 1, in which case the content of the output file is undefined and it should be ignored.</p>
<h3>Example</h3>
<p>A simple application that uses the library is included with the distribution (see the <code><a class="el" href="demo_8cpp_source.html">demo.cpp</a></code> file in the <code>example/</code> folder). The source code is given below. The input graphical model is given in the <code>pedigree1.uai</code> file, while <code>pedigree1.evid</code> contains a set of observations (ie, variable value pairs). In addition, the file <code>pedigree1.map</code> contains the query variables for the marginal MAP task. The application solves the following inference tasks (the results are written in the corresponding <code>.out</code> files):</p>
<ul>
<li>MAR = posterior marginals (ie, marginal distributions of all unobserved variables given the evidence)</li>
<li>MAP = maximum aposteriori (ie, configuration of unobserved variables having maximum probability)</li>
<li>MMAP = marginal MAP (ie, configuration of the query variables having maximum marginal probability) <pre class="fragment">  #include "merlin.h"

  void demo_run(void) {

      // Init parameters
      unsigned int ibound = 4;
      unsigned int iterations = 300;
      const char* inputFile = "pedigree1.uai";
      const char* evidenceFile = "pedigree1.evid";
      const char* queryFile = "pedigree1.map";
      const char* outputFileMAR = "pedigree1.MAR.out";
      const char* outputFileMAP = "pedigree1.MAP.out";
      const char* outputFileMMAP = "pedigree1.MMAP.out";

      // MAR task
      run(inputFile, evidenceFile, "", outputFileMAR, "MAR", ibound, iterations);

      // MAP task
      run(inputFile, evidenceFile, "", outputFileMAP, "MAP", ibound, iterations);

      // MMAP task
      run(inputFile, evidenceFile, queryFile, outputFileMMAP, "MMAP", ibound, iterations);

  }
</pre></li>
</ul>
<p>The application should be compiled with the <code>-lmerlin</code> option. It is also possible to just run the <code>example</code> wrapper script (generated automatically during by the build scripts) in the <code>example/</code> folder.</p>
<h2>Advanced API</h2>
<p>Class <code><a class="el" href="classMerlin.html">Merlin</a></code> defined in <code><a class="el" href="merlin_8h_source.html">merlin.h</a></code> header exposes most of the functionality of the library. A graphical model is a collection of factors (or positive real-valued functions) defined over subsets of variables. Variables are assumed to be indexed from <code>0</code>.</p>
<h3>Methods</h3>
<pre class="fragment">    bool read_model(const char* f)
</pre><p> This method loads the graphical model from a file which is specified using the UAI format (see also the File Formats section). Returns <code>true</code> if successful and <code>false</code> otherwise. </p><pre class="fragment">    bool read_evidence(const char* f)
</pre><p> This method loads the evidence variables and their corresponding observed values from a file which is also specified using the UAI format. Returns <code>true</code> if successful, and <code>false</code> otherwise. </p><pre class="fragment">    bool read_query(const char* f)
</pre><p> This method loads the query variables from a file specified using the UAI format. The query variables (also known as MAX of MAP variables) are only specific to Marginal MAP (MMAP) inference tasks. Returns <code>true</code> if successful, and <code>false</code> otherwise. </p><pre class="fragment">    bool set_task(size_t t)
</pre><p> This method sets the probabilistic inference task to be solved. The possible values for the <code>t</code> parameter are:</p><ul>
<li><code>MERLIN_TASK_PR</code> : Partition function (probability of evidence)</li>
<li><code>MERLIN_TASK_MAR</code> : Posterior marginals (given evidence)</li>
<li><code>MERLIN_TASK_MAP</code> : Maximum aposteriori (given evidence)</li>
<li><code>MERLIN_TASK_MMAP</code> : Marginal MAP (given evidence) <pre class="fragment">  bool set_algorithm(size_t a)
</pre> This method sets the the algorithm to be used when solving the selected probabilistic inference task. The possible values for the <code>a</code> parameter are:</li>
<li><code>MERLIN_ALGO_GIBBS</code> : Gibbs sampling</li>
<li><code>MERLIN_ALGO_LBP</code> : Loopy belief propagation</li>
<li><code>MERLIN_ALGO_IJGP</code> : Iterative join graph propagation</li>
<li><code>MERLIN_ALGO_JGLP</code> : Join graph linear programming</li>
<li><code>MERLIN_ALGO_WMB</code> : Weighted mini-bucket elimination</li>
<li><code>MERLIN_ALGO_AOBB</code> : AND/OR branch and bound search (not implemented)</li>
<li><code>MERLIN_ALGO_AOBF</code> : Best-first AND/OR search (not implemented)</li>
<li><code>MERLIN_ALGO_RBFAOO</code> : Recursive best-first AND/OR search (not implemented) <pre class="fragment">  void set_param_ibound(size_t ibound)
</pre> This method sets the i-bound parameter which is used by the following algorithms: <code>WMB</code>, <code>IJGP</code>, <code>JGLP</code> (as well as search based ones <code>AOBB</code>, <code>AOBF</code>, and <code>RBFAOO</code>). The default value is <code>4</code>. <pre class="fragment">    void set_param_iterations(size_t iter)
</pre> This method sets the number of iterations to be executed by the inference algorithm. The parameter is specific to the following algorithms: <code>WMB</code>, <code>IJGP</code>, <code>JGLP</code>, and <code>LBP</code>. The default value is <code>100</code>. For Gibbs sampling consider runnig several thousands of iterations. <pre class="fragment">    void set_param_samples(size_t s)
</pre> This method sets the number of samples to be generated in each iteration of the <code>GIBBS</code> sampling algorithm. The default value is <code>100</code>. <pre class="fragment">    void run()
</pre> This method runs the inference algorithm for the selected task on the input graphical model and evidence (if any). The output is generated into a file specified using the UAI format. The name of the output file is obtained from the input file augmented with the <code>task.out</code> suffix, where <code>task</code> corresponds to one of the follwing: <code>PR</code>, <code>MAR</code>, <code>MAP</code>, or <code>MMAP</code>.</li>
</ul>
<h3>Example</h3>
<p>A simple example using the advanced <a class="el" href="classMerlin.html">Merlin</a> API is included in the <code>example/</code>folder (i.e., <code><a class="el" href="demo_8cpp_source.html">demo.cpp</a></code> file). The source code is given below. The input graphical model is given in the <code>pedigree1.uai</code> file, while <code>pedigree1.evid</code> contains a set of observations (ie, variable value pairs). In addition, the file <code>pedigree1.map</code> contains the query variables for the Marginal MAP task. The application solves all four inference tasks and the results are written in the corresponding <code>.out</code> files. </p><pre class="fragment">    #include "merlin.h"

    void demo_api() {

        // Init parameters
        unsigned int ibound = 4;
        unsigned int iterations = 300;
        const char* model_file = "pedigree1.uai";
        const char* evid_file = "pedigree1.evid";
        const char* query_file = "pedigree1.map";

        // Initialize the Merlin engine
        Merlin eng;
        eng.set_param_ibound(4);
        eng.set_param_iterations(300);
        eng.read_model(model_file);
        eng.read_evidence(evid_file);

        // Solve a MAR task
        eng.set_task(MERLIN_TASK_MAR);
        eng.set_algorithm(MERLIN_ALGO_WMB);
        eng.run();

        // Solve a MAP task
        eng.set_task(MERLIN_TASK_MAP);
        eng.set_algorithm(MERLIN_ALGO_WMB);
        eng.run();

        // Solve a MMAP task
        eng.read_query(query_file);
        eng.set_task(MERLIN_TASK_MMAP);
        eng.run();
    }
</pre><p>The application is automatically compiled with the <code>-lmerlin</code> option. It is also possible to just run the <code>example</code> wrapper script (generated automatically during by the build scripts) in the <code>example/</code> folder.</p>
<h1>Source Code</h1>
<p>The source code is organized along the following directory structure and requires a standard GNU build using the GNU Autotools toolchain.</p>
<ul>
<li><code>src/</code> - contains the source (.cpp) files</li>
<li><code>include/</code> - contains the header (.h) files</li>
<li><code>example/</code> - contains an example program (<a class="el" href="demo_8cpp_source.html">demo.cpp</a>) that uses the library</li>
<li><code>doc/</code> - contains the documentation</li>
</ul>
<h1>Build</h1>
<p>The simplest way to compile the library is to <code>cd</code> to the directory containing the source code and type <code>./configure</code>. Then type <code>make</code> to compile the library. The binaries will be generated in the default location, <code>src/.libs/</code>. <code>make</code> will also build the example program in <code>demo/</code>. Finally, type <code>make install</code> to install the library in the default location (<code>/usr/lib</code> for the <code>libmerlin.so</code> object and <code>/usr/include</code> for <code><a class="el" href="merlin_8h_source.html">merlin.h</a></code>). When installing into a prefix owned by the root, it is recommended that the library be configured and built as a regular user, and only the <code>make install</code> phase executed with root privileges (see INSTALL for more details). </p><pre class="fragment">    -$ ./configure
    -$ make
    -$ sudo make install
</pre><p>The interface of the library is exposed in the <code><a class="el" href="merlin_8h_source.html">merlin.h</a></code> header file which must be included in the source files of the application. See demo/ for a simple example. The name of the shared library is <code>libmerlin</code>.</p>
<h2>Building the Documentation</h2>
<p><a class="el" href="classMerlin.html">Merlin</a> uses Doxygen to build automatically the reference manual of the library, and supports both <code>html</code> and <code>latex</code> (see the corresponding <code>doc/html</code> and <code>doc/latex</code> subfolders).</p>
<p>To build the entire documentation, simply run <code>doxygen merlin.doxygen</code> in the main folder <code>merlin/</code>. To generate the pdf run <code>make all</code> in the <code>doc/latex</code> subfolder).</p>
<h1>File Formats</h1>
<h2>Input File Format</h2>
<p><a class="el" href="classMerlin.html">Merlin</a> uses a simple text file format which is specified below to describe a problem instances (i.e., graphical model). The format is identical to the one used during the UAI Inference competitions.</p>
<h3>Structure</h3>
<p>The input file format consists of the following two parts, in that order: </p><pre class="fragment">    &lt;Preamble&gt;
    &lt;Factors&gt;
</pre><p>The contents of each section (denoted &lt; …&gt;=""&gt; above) are described in the following:</p>
<h4>Preamble</h4>
<p>The description of the format will follow a simple Markov network with three variables and two functions. A sample preamble for such a network is: </p><pre class="fragment">    MARKOV
    3
    2 2 3
    2
    2 0 1
    2 1 2
</pre><p>The preamble starts with one line denoting the type of network. Generally, this can be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network).</p>
<p>The second line contains the number of variables.</p>
<p>The third line specifies the cardinalities of each variable, one at a time, separated by a whitespace (note that this implies an order on the variables which will be used throughout the file).</p>
<p>The fourth line contains only one integer, denoting the number of cliques in the problem. Then, one clique per line, the scope of each clique is given as follows: The first integer in each line specifies the number of variables in the clique, followed by the actual indexes of the variables. The order of this list is not restricted (for Bayesian networks we assume that the child variable of the clique is the last one). Note that the ordering of variables within a factor will follow the order provided here.</p>
<p>Referring to the example above, the first line denotes the Markov network, the second line tells us the problem consists of three variables, let's refer to them as <code>X</code>, <code>Y</code>, and <code>Z</code>. Their cardinalities are <code>2</code>, <code>2</code>, and <code>3</code> respectively (from the third line). Line four specifies that there are 2 cliques. The first clique is <code>X,Y</code>, while the second clique is <code>Y,Z</code>. Note that variables are indexed starting with <code>0</code>.</p>
<h4>Factors</h4>
<p>Each factor is specified by giving its full table (i.e, specifying a non-negative real value for each assignment). The order of the factors is identical to the one in which they were introduced in the preamble, the first variable has the role of the 'most significant' digit. For each factor table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the factor's scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the <code>least significant</code>. To illustrate, we continue with our Markov network example from above, let's assume the following conditional probability tables: </p><pre class="fragment">    X | P(X)  
    0 | 0.436 
    1 | 0.564 

    X   Y |  P(Y,X)
    0   0 |  0.128
    0   1 |  0.872
    1   0 |  0.920
    1   1 |  0.080

    Y   Z |  P(Z,Y)
    0   0 |  0.210
    0   1 |  0.333
    0   2 |  0.457
    1   0 |  0.811
    1   1 |  0.000
    1   2 |  0.189
</pre><p>Then we have the corresponding file content: </p><pre class="fragment">    2
     0.436 0.564

    4
     0.128 0.872
     0.920 0.080

    6
     0.210 0.333 0.457
     0.811 0.000 0.189
</pre><p>Note that line breaks and empty lines are effectively just a whitespace, exactly like plain spaces “ ”. They are used here to improve readability.</p>
<h2>Evidence File Format</h2>
<p>Evidence is specified in a separate file. The evidence file consists of a single line. The line will begin with the number of observed variables in the sample, followed by pairs of variable and its observed value. The indexes correspond to the ones implied by the original problem file.</p>
<p>If, for our example Markov network, <code>Y</code> has been observed as having its first value and <code>Z</code> with its second value, the evidence file would contain the following line: </p><pre class="fragment">    2 1 0 2 1
</pre><h2>Query File Format</h2>
<p>Query variables for Marginal MAP inference are specified in a separate file. The query file consists of a single line. The line will begin with the number of query variables, followed by the indexes of the query variables. The indexes correspond to the ones implied by the original problem file.</p>
<p>If, for our example Markov network, we want to use <code>Y</code> as the query variable the query file would contain the following line: </p><pre class="fragment">    1 1
</pre><h2>Output File Format</h2>
<p>The first line must contain only the task solved: <code>PR|MAP|MAR|MMAP</code>. The rest of the file will contain the solution for the task. Solvers can write more then one solution by writing <code>-BEGIN-</code> at the head of the new solution. In the example below the task we choose is <code>PR</code>. We have two solutions. The format of the <code>&lt;SOLUTION&gt;</code> part will be described below. </p><pre class="fragment">    PR
    &lt;SOLUTION&gt;
    -BEGIN-
    &lt;SOLUTION&gt;
</pre><p>The solution format are as follows depending on the task:</p>
<h3>Partition function <code>PR</code></h3>
<p>Line with the value of the log10 of the partition function. For example, an approximation <code>log10 Pr(e) = -0.2008</code>which is known to be an upper bound may have a solution line: </p><pre class="fragment">    -0.2008
</pre> <h3>Maximum aposteriori <code>MAP</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number <code>n</code> of model variables, and</li>
<li>the MAP instantiation, a list of value indices for all <code>n</code> variables.</li>
</ul>
<p>For example, an input model with 3 binary variables may have a solution line: </p><pre class="fragment">    3 0 1 0
</pre><h3>Marginals <code>MAR</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number of variables <code>n</code> in the model, and</li>
<li>a list of marginal approximations of all the variables. For each variable its cardinality is first stated, then the probability of each state is stated. The order of the variables is the same as in the model, all data is space separated.</li>
</ul>
<p>For example, a model with <code>3</code> variables, with cardinalities of <code>2</code>, <code>2</code>, <code>3</code> respectively. The solution might look like this: </p><pre class="fragment">    3 2 0.1 0.9 2 0.3 0.7 3 0.2 0.2 0.6
</pre><h3>Marginal MAP <code>MMAP</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number <code>q</code> of query (or MAP) variables, and</li>
<li>their most probable instantiation, a list of variable value pairs for all <code>q</code> variables.</li>
</ul>
<p>For example, if the solution is an assignment of <code>0</code>, <code>1</code> and <code>0</code> to three query variables indexed by <code>2</code> <code>3</code> and <code>4</code> respectively, the solution will look as follows: </p><pre class="fragment">    3 2 0 3 1 4 0</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 14 2015 17:13:13 for Merlin by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
