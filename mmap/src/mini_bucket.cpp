/*
 * mini_bucket.cpp
 *
 *  Created on: Apr 2, 2013
 *      Author: radu
 */

#include "mini_bucket.h"

//#define DEBUG

static int __FID = 1000;

/* checks whether a function 'fits' in this MB
 * - the scope of the MB has at most i-bound + 1 different variables
 * - the message generated from this MB has at most i-bound variables
 */
bool MiniBucket::allowsFunction(Function* f) {

	const std::set<int>& a = m_jointScope, b = f->getScope();

	std::set<int>::const_iterator ita = a.begin(), itb = b.begin();

	int s = 0, d = 0;

	while (ita != a.end() && itb != b.end()) {
		d = *ita - *itb;
		if (d > 0) {
			++s;
			++itb;
		} else if (d < 0) {
			++s;
			++ita;
		} else {
			++s;
			++ita;
			++itb;
		}
	}

	while (ita != a.end()) {
		++s;
		++ita;
	}
	while (itb != b.end()) {
		++s;
		++itb;
	}

	// accept if no scope increase or new scope not greater than ibound
	return (s == (int) m_jointScope.size()) || (s <= m_ibound);
	// new scope would be greater then ibound?
	//return s <= m_ibound+1;

}

/* checks whether a function 'fits' in this MB
 * - the scope of the MB has at most i-bound different variables
 * - the message generated by the MB can have fewer than i-bound variables
 */
bool MiniBucket::allowsFunction(Function* f, const std::vector<int>& assignment) {

	std::set<int> a = m_jointScope; // should all be unassigned
	const std::set<int>& b = f->getScope();

	for (std::set<int>::const_iterator si = b.begin(); si != b.end(); ++si) {
		int var = (*si);
		if (assignment[var] == NONE) {
			a.insert(var);
		}
	}

	// accept if no scope increase or new scope not greater than ibound
	return (a.size() == m_jointScope.size()) || ((int)a.size() <= m_ibound);
	// new scope would be greater then ibound?
	//return s <= m_ibound+1;
}

/* joins the functions in the MB while marginalizing out the bucket var.,
 * resulting function is returned.
 *
 * if the bucket var is VAR_SUM then marginalize out by sum the first MB,
 * while the remaining MBs are marginalized by max.
 *
 * if the bucket var is VAR_MAX then marginalize out by max.
 *  */
Function* MiniBucket::eliminate(bool buildTable, bool first) {

#ifdef DEBUG
	cout << "  Marginalizing together:";
	for (vector<Function*>::iterator it=m_functions.begin();it!=m_functions.end();++it)
	cout << ' ' << (**it);
	cout << endl;
#endif

	std::set<int> scope;
	int i = 0;
	size_t j = 0; // loop variables

	std::vector<Function*>::const_iterator fit;
	std::set<int>::const_iterator sit;

	for (fit = m_functions.begin(); fit != m_functions.end(); ++fit) {
		scope.insert((*fit)->getScope().begin(), (*fit)->getScope().end());
	}

#ifdef DEBUG
	cout << "   Joint scope: " << scope << endl;
#endif

	// remove elimVar from the new scope
	scope.erase(m_bucketVar);
	int n = scope.size(); // new function arity

#ifdef DEBUG
	cout << "   Target scope: " << scope << endl;
#endif

	// compute new table size and collect domain sizes
	std::vector<int> domains;
	domains.reserve(n);
	size_t tablesize = 1;
	for (sit = scope.begin(); sit != scope.end(); ++sit) {
//    if (*it != elimVar)
		tablesize *= m_problem->getDomainSize(*sit);
		domains.push_back(m_problem->getDomainSize(*sit));
	}

	double* newTable = NULL;
	if (buildTable) {
		newTable = new double[tablesize];

		// initialize the table
		if (m_problem->isMap(m_bucketVar)) { // MAP variable (marg by max)
			for (j = 0; j < tablesize; ++j) {
				newTable[j] = -ELEM_INF;
			}
		} else {
			if (first) { // SUM variable (marg by sum if first mini-bucket
				for (j = 0; j < tablesize; ++j) {
					newTable[j] = ELEM_ZERO;
				}
			} else { // SUM variable (marg by max if not the first mini-bucket
				for (j = 0; j < tablesize; ++j) {
					newTable[j] = -ELEM_INF;
				}
			}
		}

		// this keeps track of the tuple assignment
		int* tuple = new int[n + 1];
		for (i = 0; i < n; ++i)
			tuple[i] = 0; // i trough n index target variables
		int* elimVal = &tuple[n]; // n+1 is elimVar

		// maps each function scope assignment to the full tuple
		std::vector<std::vector<int*> > idxMap(m_functions.size());

		// holds iterators .begin() and .end() for all function scopes
		std::vector<std::pair<std::set<int>::const_iterator, std::set<int>::const_iterator> > iterators;
		iterators.reserve(m_functions.size());
		for (fit = m_functions.begin(); fit != m_functions.end(); ++fit) {
			// store begin() and end() for each function scope
			iterators.push_back(
					make_pair((*fit)->getScope().begin(),
							(*fit)->getScope().end()));
		}

		// collect pointers to tuple values
		bool bucketVarPassed = false;
		for (i = 0, sit = scope.begin(); i < n; ++i, ++sit) {
			if (!bucketVarPassed && *sit > m_bucketVar) { // just went past bucketVar
				for (j = 0; j < m_functions.size(); ++j) {
					idxMap[j].push_back(elimVal);
					++(iterators[j].first); // skip bucketVar in the original function scope
				}
				bucketVarPassed = true;
			}
			for (j = 0; j < m_functions.size(); ++j) {
				//      cout << "  f" << funs[j]->getId() << ' ' << *sit << " == " << *(iterators[j].first) << endl;
				if (iterators[j].first != iterators[j].second // scope iterator != end()
				&& *sit == *(iterators[j].first)) { // value found
					idxMap[j].push_back(&tuple[i]);
					++(iterators[j].first);
				}
			}
		}

		if (!bucketVarPassed) { // bucketVar has highest index
			for (j = 0; j < m_functions.size(); ++j) {
				idxMap[j].push_back(elimVal);
			}
		}

#ifdef DEBUG
		if (m_problem->isMap(m_bucketVar)) {
			cout << "   Marginalize " << m_bucketVar << " by MAX" << endl;
		} else if (first) {
			cout << "   Marginalize " << m_bucketVar << " by SUM" << endl;
		} else {
			cout << "   Marginalize " << m_bucketVar << " by MAX" << endl;
		}
#endif

		// actual computation
		size_t idx;
		double z;
		// iterate over all values of elimVar
		for (*elimVal = 0; *elimVal < m_problem->getDomainSize(m_bucketVar);
				++(*elimVal)) {
			idx = 0; // go over the full new table
			do {
				// combination
				z = ELEM_ONE;
				for (j=0; j<m_functions.size(); ++j) {
					z *= m_functions[j]->getValuePtr(idxMap[j]);
				}

				// marginalization
				if (m_problem->isMap(m_bucketVar)) {
					newTable[idx] = max(newTable[idx], z);
				} else {
					if (first) {
						newTable[idx] = (newTable[idx] + z);
					} else {
						newTable[idx] = max(newTable[idx], z);
					}
				}

			} while (increaseTuple(idx, tuple, domains));

		}
		// clean up
		delete[] tuple;
	}

	return new FunctionBayes(-m_bucketVar, m_problem, scope, newTable,
			tablesize);
}

// combine all functions in the mini-bucket and return a new function
Function* MiniBucket::combine(const std::set<int>& jointScope,
		const std::vector<int>& assignment) {

	// safety checks
	if (m_functions.empty()) {
		return NULL;
	}

	// temporary assignment buffer
	std::vector<int> tempAssignment = assignment;

	// the new function
	Function* result = NULL;
	if (jointScope.empty()) { // constant function

		// compute new table size
		size_t tablesize = 1;

		// create new table
		double* newTable = new double[tablesize];
		for (size_t i = 0; i < tablesize; ++i) newTable[i] = ELEM_ZERO;

		// create a new function
		result = new FunctionBayes(-(__FID++),
				m_problem, jointScope, newTable, tablesize);

		// combine all functions on the current scope combination
		double z = ELEM_ONE;
		std::vector<Function*>::iterator it = m_functions.begin();
		for (; it != m_functions.end(); ++it) {
			Function *f = (*it);
			z *= f->getValue(tempAssignment);
		}

		// set the function value for current scope assignment
		result->setValue(z, tempAssignment);
	} else { // non-constant function

		// compute new table size
		std::vector<int> scope;
		size_t tablesize = 1;
		for (std::set<int>::const_iterator si = jointScope.begin();
				si != jointScope.end(); ++si) {
			tablesize *= m_problem->getDomainSize(*si);
			scope.push_back(*si);
		}

		// create new table
		double* newTable = new double[tablesize];
		for (size_t i = 0; i < tablesize; ++i) newTable[i] = ELEM_ZERO;

		// create a new function
		result = new FunctionBayes(-(__FID++),
				m_problem, jointScope, newTable, tablesize);

		int n = (int) jointScope.size();
		std::vector<int> tuple;
		tuple.resize(n, 0);
		tuple[n-1] = -1;

		// enumerate all separator combinations
		int i;
		while (true) {

			// enumerate "separator" variables
			for (i = n - 1; i >= 0; --i) {
				int var = scope[i];
				int lastVal = m_problem->getDomainSize(var) - 1;
				if (tuple[i] < lastVal) break;
				tuple[i] = 0;
			}

			if (i < 0) break; // done;
			++tuple[i];

			// NOW: all "separator" arguments have a specific value combination.
			for (int j = 0; j < n; ++j) {
				tempAssignment[ scope[j] ] =  tuple[j];
			}

			// combine all functions on the current scope combination
			double z = ELEM_ONE;
			std::vector<Function*>::iterator it = m_functions.begin();
			for (; it != m_functions.end(); ++it) {
				Function *f = (*it);
				z *= f->getValue(tempAssignment);
			}

			// set the function value for current scope assignment
			result->setValue(z, tempAssignment);
		} // end while
	}

	return result;
}

// first combine all functions into a new temporary one, then eliminate
// if first flag is true, than sum variables are eliminated by summation,
// otherwise (ie, first is false) all sum variables are eliminated by max
Function* MiniBucket::eliminate(const std::vector<int>& origElimVars,
		const std::vector<int>& evidence, const bool first) {

	// safety checks
	if (m_functions.empty()) { // nothing to do
		return NULL;
	}

#ifdef DEBUG
	cout << "  Marginalizing together:";
	for (vector<Function*>::iterator it=m_functions.begin();it!=m_functions.end();++it)
	cout << ' ' << (**it);
	cout << endl;
#endif

	// assemble the joint scope
	std::set<int> scope; // separator
	std::vector<Function*>::const_iterator fit;
	std::set<int>::const_iterator sit;
	for (fit = m_functions.begin(); fit != m_functions.end(); ++fit) {
		Function* f = (*fit);
		const std::set<int>& sc = f->getScope();
		for (sit = sc.begin(); sit != sc.end(); ++sit) {
			int var = (*sit);
			if (evidence[var] == NONE) {
				scope.insert(var); // keep only unassigned variables
			}
		}
	}

#ifdef DEBUG
	cout << "   Joint scope (without evidence): " << scope << endl;
#endif

	// set current evidence
	std::vector<int> assignment = evidence;

	// combine all functions: joint scope contains only non-evidence variables
	Function* comb = combine(scope, assignment);
	assert(comb != NULL);

	// variables not mentioned in the joint scope are ignored
	std::vector<int> elimVars;
	for (std::vector<int>::const_iterator it = origElimVars.begin();
			it != origElimVars.end(); ++it) {
		int var = (*it);
		if (scope.find(var) != scope.end()) {
			elimVars.push_back(var);
		}
	}

	// safety checks
	if (elimVars.empty()) { // nothing to eliminate
		return comb;
	} else {

		for (std::vector<int>::iterator vi = elimVars.begin();
				vi != elimVars.end(); ++vi) {

			// reset the assignment
			assignment = evidence;

			int elim = (*vi);
			if (assignment[elim] != NONE) {
				assert( scope.find(elim) == scope.end() );
				continue; // skip assigned 'elim' variables
			}

			scope.erase(elim); // separator
			int n = scope.size(); // new function arity

			// compute new table size
			std::vector<int> newScope;
			size_t tablesize = 1;
			for (std::set<int>::iterator si = scope.begin();
					si != scope.end(); ++si) {
				tablesize *= m_problem->getDomainSize(*si);
				newScope.push_back(*si);
			}

			// create new table
			double* newTable = new double[tablesize];
			for (size_t i = 0; i < tablesize; ++i) newTable[i] = ELEM_ZERO;

			// create a new function
			Function* tmp = new FunctionBayes(-(__FID++),
					m_problem, scope, newTable, tablesize);

			if (newScope.empty()) { // a constant function

				// loop over the eliminator variable values
				double zz = ((m_problem->isMap(elim) || !first) ? -INFINITY : ELEM_ZERO);
				for (int elimVal = 0; elimVal < m_problem->getDomainSize(elim); ++elimVal) {

					assignment[elim] = elimVal;

					// combine all functions on the current scope combination
					double z = comb->getValue(assignment);
					if (m_problem->isMap(elim) || !first) {
						zz = std::max(zz, z);
					} else {
						zz += z;
					}
				}

				// set the function value for current scope assignment
				tmp->setValue(zz, assignment);

			} else { // a non-constant function

			    // this keeps track of the tuple assignment
				std::vector<int> tuple;
				tuple.resize(scope.size(), 0);
				tuple[n-1] = -1;

				// enumerate all separator combinations
				int i;
				while (true) {

					// enumerate "separator" variables
					for (i = n - 1; i >= 0; --i) {
						int var = newScope[i];
						int lastVal = m_problem->getDomainSize(var) - 1;
						if (tuple[i] < lastVal) break;
						tuple[i] = 0;
					}

					if (i < 0) break; // done;
					++tuple[i];

					// NOW: all "separator" arguments have a specific value combination.
					for (int j = 0; j < n; ++j) {
						assignment[newScope[j]] =  tuple[j];
					}

					// loop over the eliminator values
					double zz = ((m_problem->isMap(elim) || !first) ? -INFINITY : ELEM_ZERO);
					for (int elimVal = 0; elimVal < m_problem->getDomainSize(elim); ++elimVal) {

						assignment[elim] = elimVal;

						// combine all functions on the current scope combination
						double z = comb->getValue(assignment);

						if (m_problem->isMap(elim) || !first) {
							zz = std::max(zz, z);
						} else {
							zz += z;
						}
					}

					// set the function value for current scope assignment
					tmp->setValue(zz, assignment);
				}
			} // end if

			// now we have a smaller function
			delete comb;
			comb = tmp;
		} // end for

		return comb;
	}
}


